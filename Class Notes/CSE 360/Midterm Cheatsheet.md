##### Nature of Software
- **Law of Unintended Consequences:** invention of 1 technology can have unexpected effects on other technologies (like the butterfly effect)
- Computer tech is everywhere: system software - compiler, networking **|** application software - standalone for a specific need **|** engineering/scientific software - astronomy, molecular biology... **|** embedded software **|** product-line software - inventory control, word processing, spreadsheets **|** Web applications - set of linked hypertext files **|** AI - robotics, pattern recognition, games
- **Generic products:** stand-alone systems that are marketed and sold to any customer who wishes to buy them (PC software, CAD software, Project management tools, etc.) - **the specification of what the software should do is determined by the software developer and changes are made by the developer**
- **Customized products:** commissioned by a specific customer to meet their own needs - **the specification of what the software should do is owned by the customer for the software and they make decisions on software changes that are required**
- Hardware wears out; software **deteriorates** | Hardware is manufactured; software is **engineered**
- **Software deteriorates due to (1) changes that degrade the code structure (2) changes that degrade the design (3) changes that potentially incorporate more bugs**
##### What is Software Engineering?
- **engineering:** "the application of scientific principles towards practical ends", *or* "using appropriate theories and methods to solve problems, bearing in mind organizational and financial constraints".
- **Software Engineering:** concerned with all aspects of software production from the early stages of system specification to maintaining the system after it has gone into use. **The systemic application of software engineering activities (and body of knowledge of software engineering and computer science) to build state-of-the-art software systems**.
- Different aspects of software production: process of development, project management and development of tools, methods, etc.
- **Four-Layered Technology:** (bottom to top) Quality - conformance to explicitly stated *functional* and *performance* requirements, explicitly documented *development standards* and implicit characteristics that are expected of all professionally developed software (User satisfaction = compliant product + good quality + delivery within budget and schedule) **|** Process Model - defines a framework that uses software engineering methods to build quality software **|** Methods - technical details about how to's for building software **|** Tools - provides automated or semi-automated support for methods and process
- Body of knowledge in software engineering mainly constitutes of software engineering principles and computer science theory - it is still evolving and not as mature as other engineering disciplines
##### Software Engineering vs. Computer Science
- CS primarily focuses on **fundamental principles** (theoretical aspect) of software, software systems, and computers: algorithm design techniques, software analysis and design principles, computer networks, computer architecture, etc. CS fundamental principles form the key **body of knowledge** required to develop and deliver software.
- **Software Engineering Activities:** Specification, Development, Validation, Evolution **|** **SE Body of Knowledge:** Software Process Models, Project Management, Teamwork, Software Engineering Tools **|** **CS Fundamentals:** Algorithms, Analysis, Design, Programming, Database
- **product goals:** minimal defects, maximum user satisfaction, minimal response time, good maintainability, good extendibility, high robustness, high correctness
- **project goals:** short schedule, predictable delivery date, low costs, small team size, flexibility to make mid-project feature-set changes
- Software team works on striking a balance between project and product goals.
##### Software Engineering Process Activities
- **Software Specification:** where customers, stakeholders, and engineers define the software that is to be produced and the constraints on its operation **|** **Software Development:** where the software is designed and programmed **|** **Software Validation:** Where software is checked to ensure that it is what the customer requires **|** **Software Evolution:** where software is modified to reflect changing customer and market requirements
- **Specification:** the process of establishing what services are required and the constraints on the system's operation/development.
	- **Requirement Engineering:** (1) Requirements Elicitation and Analysis - what do the system stakeholders require or expect from the system, *output* = system descriptions (2) Requirements Specifications (use cases, use case diagram) - defining the requirements in detail, *output* = user and system requirements (3) Requirements Validation - checking the validity of the requirements, *output* - requirements document
- **Development** - overall object is to convert the system specification into an executable system: *software design* - design a software structure that realizes the specification **|** *implementation* - translate this structure into an executable program
- The activities of design and implementation are closely related and may be inter-leaved.
	- **Design Inputs:** platform information - deployment and development platforms, requirements specification, data description - how and where data should be stored.
	- **Design Activities:** architectural design - blueprint of the system; general layout, interface design - connection between components, component design - each functionality
	- **Design Outputs:** system architecture, database specification, interface specification, component specification
- **Validation:** intended to show that a system meets the requirements of the system customer **|** **Verification:** intended to show that a system conforms to its specification
- Review and Testing are the most commonly used V&V activity. *Component testing -> system testing -> acceptance testing* loop
- **Evolution:** software needs to be flexible for changes (changing business circumstances). *Existing systems & system requirements -> assess existing systems -> propose system changes -> modify systems -> new system or change system requirements*.
- **Revised SE definition:** Organization of software process activities (specification, development, validation and evolution) and the application of body of knowledge of CS and relevant disciplines to deliver software product that satisfies functional and non-functional requirements
	- Software lifecycle models; software project management; software development methods and tools (information management, object-oriented analysis and design, algorithms/data structures, coding and codebase management); software testing; software QA
- **Software Engineering Development:** the term software engineering was first used at a workshop in West Germany in 1968 that considered the growing problems of software development (high costs, difficult to manage/maintain, poor reliability, lack of user acceptance). We still have the same problems today, but they are on different scales.
- **High Cost:** software development is labor intensive, and software productivity rates for engineering are not that high (1 loc) **|** **Difficult to Manage:** software projects are difficult to estimate, plan, and track, and many projects are late and over budget **|** **Poor Reliability:** defect rates are around 1 per 1000 loc. **|** **Lack of User Acceptance:** the success of a project is often a function of its GUI **|** **Difficult to Maintain:** requires both knowledge of the code as well as the application domain

| Scientist                                                                            | Engineer                                                                                          |
| ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| Learn what is true to increase the body of knowledge in their field                  | Learn what is true to apply the body of knowledge in their field to practical problems            |
| Must keep up to date with the latest additions to the body of knowledge              | Must be familiar with reliable and effective parts of the body of knowledge                       |
| Can afford to be narrow and specialized                                              | Must have a broad understanding of all the factors that affect the product that is being designed |
| Do not have to be regulated because they are chiefly accountable to other scientists | Have to be regulated because they are chiefly accountable to the public                           |
| Science education prepares students to continue their studies                        | Engineering education prepares students to enter the workforce                                    |

| Software Projects                                             | Physical Engineering Projects                                    |
| ------------------------------------------------------------- | ---------------------------------------------------------------- |
| Labor costs contribute the majority of the total project cost | Material costs contribute the majority of the total project cost |
| Focus more on optimizing project goals                        | Focus more on optimizing product goals                           |
- **Essential Properties:** properties that a thing must have to be that thing **|** **Accidental Properties:** properties that arise by happenstance and don't affect the basic "thingness" of the thing. Specific programming language and checking fidelity of representation (coding and testing) are accidental; specification, design, and verification are the essential properties.
- **Essential difficulties:** complexity - large scope, translation from real-world concepts to program **|** conformity - pre-existing hardware, third-party components, regulations, etc. **|** changeability - evolution will outpace maintainability as software gets more popular **|** invisibility - lack of visual representation.
- **Core Competencies for SE:** **Software Requirements**: the discovery, documentation, and analysis of the function to be implemented in software; **Software Design**: definition of the basic structure of the system at the architectural and detailed levels, division into modules, definition of interfaces for modules, and choice of algorithms within modules; **Software Construction**: implementation of the software including detailed design, coding, debugging, unit testing, technical reviews, and performance optimization. This area overlaps somewhat with Software Design and Software Testing; **Software Testing**: all activities associated with executing software to detect defects and evaluate features. Testing includes test planning, test case design, and specific kinds of tests including development tests, unit tests, component tests, integration tests, system tests, regression tests, stress tests, and acceptance tests; **Software Maintenance**: revision and enhancement of existing software, related documentation, and tests; **Software Configuration Management**: identification, documentation, and change control of all intellectual property generated on a software project including source code, content (graphics, sound, text, and video), requirements, designs, test materials, estimates, plans, and user documentation; **Software Quality**: all activities associated with providing confidence that a software item conforms or will conform to technical requirements. Quality engineering includes QA planning, quality measurement, reliability, testing, technical reviews, audits, and verification and validation; **Software Engineering/Project Management**: planning, tracking, and controlling of a software project, software work, or a software organization; **Software Engineering Tools and Methods**: tool and methodology support, such as CASE tools, reusable code libraries, and formal methods, including practices for adopting and disseminating tools and methods within an organization; **Software Engineering Process**: activities related to improving software development quality, timeliness, productivity, and other project and product characteristics
##### Software Project Management: 
- (1) deliver the software to the customer at the agreed time (2) keep overall costs within budget (3) deliver software that meets the customer's expectations (4) maintain a coherent and well-functioning development team
- **Software Distinctions:** the product is intangible - cannot be seen or touched, project managers cannot see progress easily **|** many software projects are 'one-off' projects - they are usually different from previous projects **|** software processes are variable and organization specific
- **Factors Influencing Project Management:** company size, software customer type(s), software size, software type, organizational culture, software development processes.
- **Universal Management Activities:** Project Planning - planning, estimating, and scheduling project development and assigning people to tasks **|** Risk Management - assessing the risks that may affect a project, monitoring these risks and taking action when problems arise **|** People Management - choosing people for their team and establishing ways of working that leads to effective team performance **|** Proposal Writing - reporting on the progress of a project to customers and to the managers of the company developing the software **|** Reporting - the first stage in a software project may involve writing a proposal to win a contract. The proposal describes the objectives of the project and how it will be carried out
##### Project Planning
- involves breaking down the work into parts and assigning these to team members, anticipating problems that might arise and preparing tentative solutions to those problems. The project plan, which is created at the start of a project, is used to communicate how work will be done, and to help assess progress on the project.
- **Planning Stages:** (1) Proposal stage - bidding for a contract to develop/provide a software system (2) Project startup phase - planning who will work on the project, how the project will be broken into increments, how resources will be allocated across your company (3) Development phase - periodically throughout the project, modify your plan in the light of experience gained
- **Proposal Planning:** planning may be necessary with only outline software requirements (UI mockup); the aim of this stage is to provide info that will be used in **setting a price** for the system to customers; project pricing involves estimating how much the software will cost to develop, as well as staff, hardware, software, and other costs into account
- **Project Startup Planning:** know more about system requirements but don't have design/implementation info; create a plan with enough detail to make decisions about the project budget and staffing, should also define project monitoring mechanisms; a startup plan is still needed for agile development
- **Development Planning:** the project plan should be regularly amended as the project progresses an you know more about the software and its development, including the project schedule, cost-estimate/risks. 
##### Plan-Driven vs. Agile Development
- **plan-driven:** development process is planned in detail, based on engineering project management techniques and is the 'traditional' method; a project plan is created that records the work to be done, who will do it, the schedule and the work products; managers use the plan to support project decision-making and to measure progress **|** **Pros** - early planning allows organizational issues to be closely taken into account, potential problems and dependencies are discovered before the project starts, rather than once the project is underway; **Cons** - many early decisions have to be revised because of changes to the environment
- project plan sections: **Introduction**: what is the main goal of the project, who is involved (stakeholders); **Project organization**: staffing and team structure, tools that you might need to use for the software; **Risk analysis**: and contingency plan for the risks; **Hardware and software resource requirements**: properly listed; **Work breakdown**: create schedule of working and assign staff; **Project schedule**: Set up milestones and timeline; **Monitoring and reporting mechanisms**: how we evaluate milestones and who will be doing the evaluation, and based on evaluation how do we adapt if changes are needed

| Plan                          | Description                                                                                                                                                           |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Configuration management plan | Describes the configuration management procedures and structures are to be used.                                                                                      |
| Deployment plan               | Describes how the software/hardware(if required) will be deployed in the customer's environment. This should include a plan for migrating data from existing systems. |
| Maintenance plan              | Predicts the maintenance requirements, costs, and effort.                                                                                                             |
| Quality plan                  | Describes the quality procedures and standards that will be used.                                                                                                     |
| Validation plan               | Describes the approach, resources, and schedule used for system validation                                                                                            |
- **Planning Process:** iterative process that starts when you create an initial project plan during the project startup phase; plan changes are inevitable. **Assumptions:** you should make realistic rather than optimistic assumptions; problems of some description always arise during a project; your initial assumptions and scheduling should take unexpected problems into account; contingency should be included in plan
- **Risk Mitigation:** if there are serious problems, risk mitigation actions need to be initiated to reduce the risks of project failure. This may involve renegotiating the project constraints and deliverables with the customer.
##### Agile Planning
- Agile methods are **iterative approaches** where the software is developed and delivered to customers in increments; unlike plan-driven, the functionality of these increments is not planned in advance but is decided **during** the development, **design and implementation are interleaved**.
- The system is developed as a **series of versions/increments** with **stakeholders involved** in version specification and evaluation; **frequent delivery of new versions for evaluation**, extensive tool support, minimal documentation - **focus on working code** - iteration planning, which has a shorter-term outlook
- The planning is based on user stories that reflect the desired features; the team reads/discusses the stories and ranks them in order of the amount of time they think it will take to implement the story. They are assigned 'effort points' reflecting their size/difficulty of implementation. The number of effort points per day gives an estimate of the team's velocity.
- **Task Allocation:** during the task planning stage, devs break down stories into development tasks and individual developer sign up for specific tasks. **Benefits:** whole team gets an overview of the tasks to be completed in an iteration, developers have a sense of ownership in these tasks
- **Software Delivery:** a software increment is always delivered at the end of each iteration; **Planning Difficulties:** (1) Agile planning is reliant on customer involvement and availability (2) representatives sometimes have to prioritize other work (3) some customers may be more familiar with traditional project plans
- **Applicability:** agile planning work well with **small, stable dev. teams** that can get together and discuss the stories - however, where teams are large and/or geographically distributed, it is practically impossible for everyone to be involved in the collaborative planning that is essential for agile project management.
##### Teamwork
- **Software Teams:** almost impossible for one person to complete non-trivial software projects; a cohesive group with team spirit, motivated by the success of the group as well as by their own personal goals in needed. Group interaction is a key determinant of group performance.
- Members should consider the group to be more important than any individual in it. The advantages of a cohesive group are: (1) group quality standards can be developed by the group members (2) team members learn from each other and get to know each other's work; inhibitions caused by ignorance are reduced (3) knowledge is shared; continuity can be maintained if a group member leaves (4) refactoring and continual improvement is encouraged; group members work collectively to deliver high quality results and fix problems, irrespective of the individuals who originally created the design or program
- Team spirit promotes inclusivity, encouragement, investment, benefits, getting to know each other, and social fun.
- **Team Models:** Chief Programmer Team (CPT) - hierarchical; Matrix Management (MM) - assembly line, linear; Self-Directed Work Teams (SDWT) - no specific structure
- **CPT** - 5-10 programmers led by a chief programmer, all supervised by a manager, all members active throughout development, one or two programmers responsible for software QA. **Advantages:** established chain of command, easy accountability. **Disadvantages:** success dependent upon competence of chief programmer, non-specialist programmers for each task. Good for projects where requirements are clearly defined and requirements can easily be divided into tasks, mostly applicable for plan-driven approach
- **MM:** Each member of the group has a specialized role, only remains in the group when his services are needed, members may be moved to other projects when their assigned tasks are completed. **Advantages:** matrix assures that projects get specially trained people in all activities. **Disadvantages:** difficult to have a good schedule once delays are induced, lot of communication and lack of accountability. Good for companies developing multiple projects simultaneously and each phase of these projects need specialized people.
- **SDWT:** no technical leader, external management or matrix groupings; teams empowered to conduct all activities like hiring, planning, scheduling, tracking, rewarding, etc. **Advantages:** good cohesiveness between team members, minimum external influence. **Disadvantages:** difficult to track progress. Good for projects where requirements aren't clearly defined, specifically R&D.
- MOI model of leadership: **Motivation** - the ability to encourage (by push or pull) technical people to produce to their best ability; **Organization:** the ability to mold existing processes (or invent new ones) that will enable the initial concept to be translated into a final product; **Ideas or Innovation:** the ability to encourage people to create and feel creative even when they must work within established bounds
- **Team effectiveness:** the people in the group (team composition) - diverse and specialized; the group organization - individuals can contribute to the best of their abilities; technical and managerial communications - good communication between team members and stakeholders is essential.
- **Composition:** the following factors must be considered when selecting a team structure - the difficulty of the problem, the size of the resultant program(s), the time that the team will stay together, the modularity of the problem, the required quality/reliability of the system to be built, the rigidity of the delivery date, the degree of sociability required for the project
- Groups composed of similar members can be problematic: task-oriented - everyone wants to do their own thing; self-oriented - everyone wants to be the boss; interaction-oriented - everyone is chatting too much -> an effective group has a balance
##### Software Process Models
- A **process model** is a structured set of activities required to develop a software system - the universal activities involve **specification**, **design** and **implementation**, **validation**, and **evolution**. A software process model is an abstract representation of a process - it presents how different process activities are organized for a given process model.
- **Waterfall** - models where all of the process activities are planned in advance, and progress is measured against this plan (Linear Process Models - Waterfall; Linear Process Models w/ feedback - V-Model; Evolutionary Process Models - Prototyping, Spiral); **Incremental** - planning is incremental, and it is easier to change the process to reflect changing customer requirements (Incremental Model; XP; Scrum; Kanban). In practice, most process models use elements of both - they bring order to the software development process with the intention of producing high-quality products on time and within budget.
##### Waterfall Software Process Models
- Requirements Analysis and Definition -> System and Software Design -> Implementation and Unit Testing -> Integration and System Testing -> Operation and Maintenance; in principle, one phase has to be completed before moving onto the next phase. **Problems:** inflexible partitioning of the project makes it difficult to respond to changing customer requirements. This model is good if a large system is developed at several sites. In those circumstances, the plan-driven nature of the waterfall model helps coordinate the work.
- **Prototyping Variation:** (Prototyping Section connected to Requirements Definition/System and Software Design) stakeholders can look at the prototype, and several iterations can be used to refine the design and requirements
- **V-Model:** Requirements Definition -> System Analysis -> Software Design -> Module Design -> Coding -> Unit Testing -> Integration Testing -> System Testing -> Validation Testing, with Coding at the bottom of the V. Adds flexibility with feedback loops.
##### Incremental Software Process Models
- **Incremental Model:** (1) Develop an initial version (2) get stakeholder feedback (3) evolve into the next version (iteration) (4) repeat; specification, development, and validation are interleaved. **Benefits:** cost of accommodating changing customer requirements is reduced - amount of redoing is much less than waterfall; easier to get customer feedback on work; more rapid delivery and deployment of useful software to the customer is possible. No reduced cost of development. **Problems:** the process is not visible, and system structure tends to degrade as new increments are added.
##### Agile Process Models
- Requirements for many small/medium size software systems increase, and they change because of changes in team members, in software being built, and because of new tech.
- **Agile Manifesto:** (1) Individuals and interactions over processes and tools (2) working software over comprehensive documentation (3) customer collaboration over contract negotiation (4) responding to change over following a plan
- The aim of agile methods is to reduce overheads in the software process (e.g. by limiting documentation) and to be able to respond quickly to changing requirements without excessive rework. **Principles:** customer involvement, incremental delivery, people not process, embrace change, maintain simplicity
- **Applicability:** product development for a small/medium-sized product for sale, custom system development within an organization
- **XP** - most widely used agile process: new versions may be built several times per day, increments are delivered to customers every 2 week, all test must be run for every build and the build is only accepted if test run successfully. **Planning:** begins with the creation of "user stories"; team assesses each story and assigns a cost, groups them for a deliverable increment, and a commitment is made on delivery date. **Design:** simple designs (CRC cards), keep is simple, suggest the creation of spike solutions (prototypes), encourages refactoring. **Coding:** pair programming (1 codes, 1 reviews, doesn't speed up but improves quality), unit testing before coding commences, continuous integration, iterative refactoring, collective ownership; **Testing:** acceptance testing is defined by the customer and executed to assess customer visible functionality, unit testing is execute daily; **Release:** software increment, project velocity computed
- **User Stories for Requirements:** a customer/user is part of the XP team and is responsible for making decisions on requirements. Stories are written on cards and the development team breaks them down into implementation tasks. The customer chooses the stories for inclusion in the next release based on their priorities and the schedule estimates. 
- **Practices:** incremental planning, small releases, simple design, test-first development, refactoring, pair programming, collective ownership, continuous integration, sustainable pace, on-site customer. **Problems:** can be difficult to keep the interest of customers who are involved, team members may be unsuited to intense involvement, prioritizing changes can be difficult when there are multiple stakeholders, maintaining simplicity requires extra work.
- **Scrum:** an agile method that focuses on managing iterative rather than specific agile practices - 3 phases: **initial phase** - an outline planning phase where general objectives for the project and software architecture design is done; **series of sprint cycles** - each cycle develops an increment; **project closure phase** - wraps up the project, completes required documentation, and assesses the lessons learned from the project
- **Terminology:** Development team, Potentially Shippable Product Increment, Product Backlog, Product Owner, Scrum, ScrumMaster (no project manager) Spring, Velocity
- **Sprint Cycle:** usually 2-4 weeks, starting point for planning is in the product backlog, which is the list of work to be done on the project. Selection phase involves all of the project team who work with the customer to select the features and functionality from the product backlog to be developed during the sprint. Once these are agreed, the team organizes themselves to develop the software - the team is then isolated from the customer and the organization, with all communications channeled through the 'ScrumMaster', whose role is to protect the dev. team from external distractions. At the end of the sprint, the work done is reviewed and presented to stakeholders.
- **Teamwork:** the ScrumMaster is a facilitator who arranges daily scrums (meetings), tracks the backlog, records decisions, measures progress and communicates with customer/management outside the team. scrums allow team members to share info, describe their progress, problems that have arisen and what is planned for the following day.
- **Benefits:** The product is broken down into a set of manageable and understandable chunks; Unstable requirements don't hold up progress; the whole team has visibility of everything and consequently team communication is improved; customers see on-time delivery of increments and gain feedback on how the product works; Trust between customers and developers is established and a positive culture is created in which everyone expects the project to succeed.
##### Process Improvement and Maturity
- the existence of a software process model is no guarantee that the software will meet any expectations - they must be coupled with solid software engineering practice. Many companies have turned to software process improvement as a way of enhancing their software quality, reducing costs/accelerating their dev. process.
- **Process maturity approach:** focuses on improving process and project management and introducing good software engineering practice; **agile approach:** focuses on iterative development and reduction of overheads
- **Process Measurement:** measure one or more attributes of the software process/product. These form a baseline for judgement; **Process Analysis:** process weaknesses and bottlenecks are identified. Process models that describe the process may be developed; **Process Change:** process changes are proposed to address weaknesses.
- **Process Measurement:** whenever possible, quantitative data should be collected, which is very difficult w/o clearly defined process standard; measurements should be used to assess process improvements, but makes sure to have the organization objectives as the driver for the improvement, not the measurements; **Examples:** time taken for process activities to be completed, resources required, number of occurrences of a particular event
- **Capability Maturity Levels:** application of process management and quality improvement concepts to software dev. and maintenance.
- **CMMI Levels:** Level 1: Initial - essentially uncontrolled, **Characteristics:** chaotic, unpredictable cost, schedule, and quality performance, success depends on competence and heroics of individuals, **Needed Actions:** planning, performance tracking, change control, commitment management, quality assurance; Level 2: Repeatable (Managed) - Product management procedures defined and used, **Characteristics:** intuitive, cost and quality highly variable, reasonable control of schedules, informal and ad hoc process methods and procedures, process capability can be summarized as discipline because project planning and tracking are stable and earlier successes can be repeated, **Needed Actions:** develop process standards and definitions, assign process resources, establish methods; Level 3: Defined - Process management procedures and strategies defined and used, **Characteristics:** reliable costs and schedules, improving but unpredictable quality performance, process capability summarized as standard and consistent due to stable and repeatable software engineering and management activities, **Needed Actions:** process measurements, quantitative quality goals, plans, tracking; Level 4: Quantitatively Managed - Quality management strategies defined and used, **Characteristics:** reliable statistical control over product quality, process capability can be summarized as being quantifiable and predictable because the process is measured and operates within measurable limits, **Needed Actions:** quantitative productivity plans and tracking, instrumented process environment, economically justified tech investments; Level 5: Optimizing - Process improvement strategies defined and used, **Characteristics:** quantitative basis for continued capital investment in process automations and improvement, process capability is continuously improving, **Needed Actions:** continued emphasis on process measurement and process methods for error prevention.
##### Software Process Activities
- real software processes are interleaved sequences of technical, collaborative and managerial activities with the overall goal of specifying, designing, implementing, and testing a software system: Specification (requirement engineering), Development (design and implementation), Validation, Evolution
- **Software Specification and Requirement Engineering:** *Requirements Elicitation and Analysis*: what do the system stakeholders require or expect from the system? *Requirements Specification*: defining the requirements in detail. *Requirements Validation*: checking the validity of the requirements. System Descriptions: UI Walkthrough, Deployment Diagram; User and System Requirements: User Stories, Use Cases/Use Case Diagrams, SRS Document.
- **Design and Implementation:** **Inputs**: *Requirements Specification*: tells the major functional/nonfunctional requirements; *Data Description:* what kind of data is needed in our system? How will it be interacted with? How is data structured to satisfy those interactions?; *Platform Information*: How are we going to deploy the software in the runtime environment - OS, protocols, etc. **Activities:** *Architectural Design* - Identify the overall structure of they system, the principal components (subsystems/modules) their relationships and how they are distributes. *Interface Design* (protocols, UI, etc.) - where you define the interfaces between the principal components, their 'relationships'. *Component Design* (class diagrams): How each component is designed, identifying objects, reusable components.*Database Design*: what database system is being used? Where the system data structures are designed and their representations. **Outputs:** *System Architecture:* deployment diagram, interaction diagram; *Database Specification:* data entities, attributes in the data structures, relationships between entities, how is data stored, E-R Diagram; *Interface Specification:* how sill the UI and other interfaces look? Component Diagram. *Component Specification*: class diagram.
- **Verification and Validation:** system **conforms to its specification** and **meets the requirements of the system customer**. Involves **checking and review processes** and **system testing** (executing with test cases derived from the specification of the real data to be processed by the system). **Component testing (JUnit, Nuint, DBunit), System Testing (state diagrams, sequence diagrams, interaction diagrams), Customer/Acceptance Testing (use-case based testing, random testing)**
##### Software Requirement Engineering
- Potential stakeholders: end users, system managers, software engineers/developers, system owners, external stakeholders, project managers, customers, sales people
- **Functional Requirements:** statements of functionalities that the system should provide, how the system should react to particular inputs and how the system should behave in particular situations; basically, what the system should and shouldn't do. *User Requirements:* high-level statements of what the system should do; *System Requirements:* should describe the system features in detail, what and how. 
- **Non-functional Requirements:** constraints on the functionalities offered by the system such as timing constraints, performance constraints, regulations, etc. Often apply to the system as a whole rather than individual features or services.
	- **Product requirements** - specify that the product must behave in a particular way e.g. execution speed, reliability, etc. *Usability Requirements* - how easy it is to use/learn the system; *Efficiency Requirements* - time and space performance; *Dependability Requirements* - how robust and reliable; *Security Requirements:* how secure
	- **Organizational requirements** - are a consequence of organizational policies and procedures e.g. process standards used, implementation requirements, etc. *Environmental Requirements*; *Operation Requirements*; *Development Requirements*
	- **External requirements** - arise from factors which are external to the system and its development process e.g. interoperability requirements, legislative requirements, etc. *Regulatory Requirements*; *Ethical Requirements*; *Legislative Requirements*
- Problems arise when functional requirements aren't precisely stated. Ambiguous requirements may be interpreted in different ways be developers and users. Use feedback to solve this. 
- In principle, requirements should be both complete (include descriptions of all facilities required) and consistent (no conflicts or contradictions in the descriptions of the system facilities)
- **Implementation**: non-functional requirements may affect overall system architecture rather than the individual components. A single non-functional requirement may generate a number of related functional requirements.
- **Metrics:** *Speed:* transactions/second, user/event response time, screen refresh time; *Size:* Mbytes, number of ROM chips; *Ease of Use:* training time, number of help frames; *Reliability:* mean time to failure, probability of unavailability; *Robustness:* time to restart after failure, percentage of event causing failure, probability of data corruption on failure; *Portability:* percentage of target dependent statements, number of target systems
- **ISO-25010 Software Quality Framework:** Functionality, Compatibility, Reliability, Usability, Efficiency, Maintainability, Portability, Security; **Software quality represents both functional and non-functional requirements.**
- **Requirements Elicitation:** working with system stakeholders to find out about the application domain, the services that the system should provide, required system performance, hardware constraints, etc. **Problems:** stakeholders don't know what they really want, they express requirements in their own terms, different stakeholders may have conflicting requirements, organizational and political factors, and changing requirements.
- **Ways of Writing a SRS:** natural language, structured natural language, design description languages, graphical notations, or mathematical specifications.
- **Use-Case Based Representation of Requirements:** *Use-Cases* - representation of a distinct functionality of a system, a major use, should represent a verb. *Actors:* an entity that performs key roles in the given system, interacts with a use case. *Use-Case Diagram:* shows how actors interact with use-cases, relationship among actors and relationship among use-cases. *Use-Case Scenarios:* a narrative that describes activities associated with the use-case
- **Use-Case Diagram Relationships:** *Includes/Uses:* when a use-case is depicted as using the functionality of another use-case in a diagram. *Extends:* the child-user case adds to the existing functionality and characteristics of the parent use--case. "may involve the usage of", the parent is the origin of the arrow. *Generalization:* the child use-case is the 'subclass' of the parent use-case, which is the end of the arrow.
##### Fundamentals of Object-Oriented Analysis and Design
- OOP concerns the design of software modules of a system as a collection of objects, where an object represents a collection of related **functionality** and **data**. An object is a computational entity that encapsulates fields (state) and methods (behavior).
- **Foundations of Software Design:** (1) Abstraction - data and procedural abstraction (2) Modularity - how well objects abstract underlying data and procedures so that each object is as independent as possible (3) Architecture - overall structure of the software system, organization of objects in the design and their behavior at runtime
- An encapsulated object can be though of as a *black box* - its inner working are hidden from the client, who can only invoke the interface methods of the object. OOP facilitates **Encapsulation and information hiding**, which reduces the likelihood of "side effects", limits the global impact of local design decisions, emphasizes communication through controlled interfaces, discourages the use of global data, results in higher quality software.
##### Object-Oriented Analysis and Modeling
- **Approach:** (1) Identify Actors and Use Cases (2) Develop each use case diagram (3) Develop each use case scenario (4) Identify objects (5) establish high-level object relationships (CRC)
- **Categorization of Classes:** *Boundary* - classes that interact with entities outside of the system (UI, external database, API, OS, etc.), serves as an interface, reduces complexity, helps maintainability. *Entity* - classes that contain all the data, procedures, algorithms, etc. All the computations + internal database operations, independent of the system's interfaces, corresponds to real-world entities that the system manipulates, represents computations, algorithms, and data, "Heart of the system". *Control* - classes that interface between boundary and entity classes, responsible for receiving/handling system events, encapsulating behavior of use case (often one control class per each use case), 
- **External Entities:** other systems, devices, people, etc. that produce or consume information to be used by a computer-based system. **Things:** reports, displays, letters, signals, etc. that are part of the information domain for the problem. **Events:** significant actions that occur within the context of system operation.
- **Analysis Classes:** Roles played by people who interact with the system, organizational units that are relevant to an application, places that establish the context of the problem and the overall function of the system, structures that define a class of objects or related classes of objects 
- **Defining Operations:** manipulate data in some way, perform a computation, inquire about the state of an object, monitor an object for the occurrence of a controlling event
- **CRC Diagrams and Class Diagram:** former represents the responsibilities of each class and other collaborating classes to achieve those functionalities. Latter describe static structure of the system, objects/classes including attributes and operations, and relationship among them.
- **CRC Diagrams:** like an index card set where each index card has three portions: *Class:* name of the class and a description of the class indicating main functionality, *Responsibility:* lists main functionalities of the class, *Collaborator:* collaborator classes for each functionality
- Use-case diagram represents the high-level dynamic view of the system. It depicts main functionalities, their relationship, and entities (actors) that invoke these functionalities. Use-case diagram doesn't show how functionalities will be implemented.
##### Documenting Software Analysis
- Class relationships can be: **structural** - objects share data and methods (association - more loosely coupled connections, aggregation - "has a" relationship, composition - "whole to part" relationship, generalization (inheritance)), or **non-structural** (dependency) - objects don't share attributes or methods; one calls the other.
- **Structural System Modeling:** sequence, use-case, class, state diagrams. LOOK CLOSELY AT CODE!!!
##### Nature of Software
- **Law of Unintended Consequences:** invention of 1 technology can have unexpected effects on other technologies (like the *butterfly effect*)
- Computer tech is everywhere: *system software* - compiler, networking **|** *application software* - standalone for a specific need **|** *engineering/scientific software* - astronomy, molecular biology... **|** *embedded software* **|** *product-line software* - inventory control, word processing, spreadsheets **|** *Web applications* - set of linked hypertext files **|** *AI* - robotics, pattern recognition, games
- **Generic products:** stand-alone systems that are marketed and sold to any customer who wishes to buy them (PC software, CAD software, Project management tools, etc.) - **the specification of what the software should do is determined by the software developer and changes are made by the developer**
- **Customized products:** commissioned by a specific customer to meet their own needs - **the specification of what the software should do is owned by the customer for the software and they make decisions on software changes that are required**
- Hardware wears out; software **deteriorates** | Hardware is manufactured; software is **engineered**
- **Software deteriorates due to (1) changes that degrade the code structure (2) changes that degrade the design (3) changes that potentially incorporate more bugs**
##### What is Software Engineering?
- **engineering:** "the application of scientific principles towards practical ends", *or* "using appropriate theories and methods to solve problems, bearing in mind organizational and financial constraints".
- **Software Engineering:** concerned with all aspects of software production from the early stages of system specification to maintaining the system after it has gone into use. **The systemic application of software engineering activities (and body of knowledge of software engineering and computer science) to build state-of-the-art software systems**.
- Different aspects of software production: process of development, project management and development of tools, methods, etc.
- **Four-Layered Technology:** (bottom to top) Quality - conformance to explicitly stated *functional* and *performance* requirements, explicitly documented *development standards* and implicit characteristics that are expected of all professionally developed software (User satisfaction = compliant product + good quality + delivery within budget and schedule) **|** Process Model - defines a framework that uses software engineering methods to build quality software **|** Methods - technical details about how to's for building software **|** Tools - provides automated or semi-automated support for methods and process
- Body of knowledge in software engineering mainly constitutes of software engineering principles and computer science theory - it is still evolving and not as mature as other engineering disciplines
##### Software Engineering vs. Computer Science
- CS primarily focuses on **fundamental principles** (theoretical aspect) of software, software systems, and computers: algorithm design techniques, software analysis and design principles, computer networks, computer architecture, etc. CS fundamental principles form the key **body of knowledge** required to develop and deliver software.
- **Software Engineering Activities:** Specification, Development, Validation, Evolution **|** **SE Body of Knowledge:** Software Process Models, Project Management, Teamwork, Software Engineering Tools **|** **CS Fundamentals:** Algorithms, Analysis, Design, Programming, Database
- **product goals:** minimal defects, maximum user satisfaction, minimal response time, good maintainability, good extendibility, high robustness, high correctness
- **project goals:** short schedule, predictable delivery date, low costs, small team size, flexibility to make mid-project feature-set changes
- Software team works on striking a balance between project and product goals.
##### Software Engineering Process Activities
- **Software Specification:** customers, stakeholders, and engineers define the software and the constraints on its operation **|** **Software Development:** where the software is designed and programmed **|** **Software Validation:** Where software is checked to ensure that it meets user requirements **|** **Software Evolution:** where software is modified to reflect changing customer and market requirements
- **Specification:** the process of establishing what services are required and the constraints on the system's operation/development.
	- **Requirement Engineering:** (1) Requirements Elicitation and Analysis - what do the system stakeholders require or expect from the system, *output* = system descriptions (2) Requirements Specifications (use cases, use case diagram) - defining the requirements in detail, *output* = user and system requirements (3) Requirements Validation - checking the validity of the requirements, *output* = requirements document
- **Development** - overall object is to convert the system specification into an executable system: *software design* - design a software structure that realizes the specification **|** *implementation* - translate this structure into an executable program
- The activities of design and implementation are closely related and may be inter-leaved.
	- **Design Inputs:** platform information - deployment and development platforms, requirements specification, data description - how and where data should be stored. **Design Activities:** architectural design - blueprint of the system; general layout, interface design - connection between components, component design - each functionality. **Design Outputs:** system architecture, database specification, interface specification, component specification
- **Validation:** intended to show that a system meets the requirements of the system customer **|** **Verification:** intended to show that a system conforms to its specification
- Review and Testing are the most commonly used V&V activity. *Component testing → system testing → acceptance testing* loop
- **Evolution:** software needs to be flexible for changes (changing business circumstances). *Existing systems & system requirements → assess existing systems → propose system changes → modify systems → new system or change system requirements*.
- **Revised SE definition:** Organization of software process activities (specification, development, validation and evolution) and the application of body of knowledge of CS and relevant disciplines to deliver software product that satisfies functional and non-functional requirements
	- Software lifecycle models; software project management; software development methods and tools (information management, object-oriented analysis and design, algorithms/data structures, coding and codebase management); software testing; software QA
- **Software Engineering Development:** the term software engineering was first used at a workshop in West Germany in 1968 that considered the growing problems of software development (high costs, difficult to manage/maintain, poor reliability, lack of user acceptance). We still have the same problems today, but they are on different scales.
- **High Cost:** software development is labor intensive, and software productivity rates for engineering are not that high (1 loc) **|** **Difficult to Manage:** software projects are difficult to estimate, plan, and track, and many projects are late and over budget **|** **Poor Reliability:** defect rates are around 1 per 1000 loc. **|** **Lack of User Acceptance:** the success of a project is often a function of its GUI **|** **Difficult to Maintain:** requires both knowledge of the code as well as the application domain

| Scientist                                                                            | Engineer                                                                                          |
| ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| Learn what is true to increase the body of knowledge in their field                  | Learn what is true to apply the body of knowledge in their field to practical problems            |
| Must keep up to date with the latest additions to the body of knowledge              | Must be familiar with reliable and effective parts of the body of knowledge                       |
| Can afford to be narrow and specialized                                              | Must have a broad understanding of all the factors that affect the product that is being designed |
| Do not have to be regulated because they are chiefly accountable to other scientists | Have to be regulated because they are chiefly accountable to the public                           |
| Science education prepares students to continue their studies                        | Engineering education prepares students to enter the workforce                                    |

| Software Projects                                             | Physical Engineering Projects                                    |
| ------------------------------------------------------------- | ---------------------------------------------------------------- |
| Labor costs contribute the majority of the total project cost | Material costs contribute the majority of the total project cost |
| Focus more on optimizing project goals                        | Focus more on optimizing product goals                           |

- **Essential Properties:** properties that a thing must have to be that thing **|** **Accidental Properties:** properties that arise by happenstance and don't affect the basic "thingness" of the thing. Specific programming language and checking fidelity of representation (coding and testing) are accidental; specification, design, and verification are the essential properties.
- **Essential difficulties:** complexity - large scope, translation from real-world concepts to program **|** conformity - pre-existing hardware, third-party components, regulations, etc. **|** changeability - evolution will outpace maintainability as software gets more popular **|** invisibility - lack of visual representation.
- **Core Competencies for SE:** **Software Requirements**: the discovery, documentation, and analysis of the function to be implemented in software; **Software Design**: definition of the basic structure of the system at the architectural and detailed levels, division into modules, definition of interfaces for modules, and choice of algorithms within modules; **Software Construction**: implementation of the software including detailed design, coding, debugging, unit testing, technical reviews, and performance optimization. This area overlaps somewhat with Software Design and Software Testing; **Software Testing**: all activities associated with executing software to detect defects and evaluate features. Testing includes test planning, test case design, and specific kinds of tests including development tests, unit tests, component tests, integration tests, system tests, regression tests, stress tests, and acceptance tests; **Software Maintenance**: revision and enhancement of existing software, related documentation, and tests; **Software Configuration Management**: identification, documentation, and change control of all intellectual property generated on a software project including source code, content (graphics, sound, text, and video), requirements, designs, test materials, estimates, plans, and user documentation; **Software Quality**: all activities associated with providing confidence that a software item conforms or will conform to technical requirements. Quality engineering includes QA planning, quality measurement, reliability, testing, technical reviews, audits, and verification and validation; **Software Engineering/Project Management**: planning, tracking, and controlling of a software project, software work, or a software organization; **Software Engineering Tools and Methods**: tool and methodology support, such as CASE tools, reusable code libraries, and formal methods, including practices for adopting and disseminating tools and methods within an organization; **Software Engineering Process**: activities related to improving software development quality, timeliness, productivity, and other project and product characteristics
##### Software Project Management: 
- (1) deliver the software to the customer at the agreed time (2) keep overall costs within budget (3) deliver software that meets the customer's expectations (4) maintain a coherent and well-functioning development team
- **Software Distinctions:** the product is intangible - cannot be seen or touched, project managers cannot see progress easily **|** many software projects are 'one-off' projects - they are usually different from previous projects **|** software processes are variable and organization specific
- **Factors Influencing Project Management:** company size, software customer type(s), software size, software type, organizational culture, software development processes.
- **Universal Management Activities:** *Project Planning* - planning, estimating, and scheduling project development and assigning people to tasks **|** *Risk Management* - assessing and monitoring the risks that may affect a project, and taking action when problems arise **|** *People Management* - choosing people for their team and establishing ways of working that lead to effective team performance **|** *Proposal Writing* - reporting on the progress of a project to customers and management **|** *Reporting* - the first stage in a software project may involve writing a proposal to win a contract, which describes the objectives of the project and how it will be carried out
##### Project Planning
- involves breaking down the work into parts and assigning these to team members, anticipating problems that might arise and preparing tentative solutions to those problems. The project plan, which is created at the start of a project, is used to communicate how work will be done, and to help assess progress on the project.
- **Planning Stages:** (1) Proposal stage - bidding for a contract to develop/provide a software system (2) Project startup phase - planning who will work on the project, how the project will be broken into increments, how resources will be allocated across your company (3) Development phase - periodically throughout the project, modify your plan in the light of experience gained
- **Proposal Planning:** planning may be necessary with only outline software requirements (UI mockup); the aim of this stage is to provide info that will be used in **setting a price** for the system to customers; project pricing involves estimating how much the software will cost to develop, as well as staff, hardware, software, and other costs into account
- **Project Startup Planning:** know more about system requirements but don't have design/implementation info; create a plan with enough detail to make decisions about the project budget and staffing, should also define project monitoring mechanisms; a startup plan is still needed for agile development
- **Development Planning:** the project plan should be regularly amended as the project progresses an you know more about the software and its development, including the project schedule, cost-estimate/risks. 
##### Plan-Driven vs. Agile Development
- **plan-driven:** development process is planned in detail, based on engineering project management techniques and is the 'traditional' method; a project plan is created that records the work to be done, who will do it, the schedule and the work products; managers use the plan to support project decision-making and to measure progress **|** **Pros** - early planning allows organizational issues to be closely taken into account, potential problems and dependencies are discovered before the project starts, rather than once the project is underway; **Cons** - many early decisions have to be revised because of changes to the environment
- project plan sections: **Introduction**: what is the main goal of the project, who is involved (stakeholders); **Project organization**: staffing and team structure, tools that you might need to use for the software; **Risk analysis**: and contingency plan for the risks; **Hardware and software resource requirements**: properly listed; **Work breakdown**: create schedule of working and assign staff; **Project schedule**: Set up milestones and timeline; **Monitoring and reporting mechanisms**: how we evaluate milestones and who will be doing the evaluation, and based on evaluation how do we adapt if changes are needed

| Plan                          | Description                                                                                                                                                           |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Configuration management plan | Describes the configuration management procedures and structures are to be used.                                                                                      |
| Deployment plan               | Describes how the software/hardware(if required) will be deployed in the customer's environment. This should include a plan for migrating data from existing systems. |
| Maintenance plan              | Predicts the maintenance requirements, costs, and effort.                                                                                                             |
| Quality plan                  | Describes the quality procedures and standards that will be used.                                                                                                     |
| Validation plan               | Describes the approach, resources, and schedule used for system validation                                                                                            |
- **Planning Process:** iterative process that starts when you create an initial project plan during the project startup phase; plan changes are inevitable. **Assumptions:** you should make realistic rather than optimistic assumptions; problems of some description always arise during a project; your initial assumptions and scheduling should take unexpected problems into account; contingency should be included in plan
- **Risk Mitigation:** if there are serious problems, risk mitigation actions need to be initiated to reduce the risks of project failure. This may involve renegotiating the project constraints and deliverables with the customer.
##### Agile Planning
- Agile methods are **iterative approaches** where the software is developed and delivered to customers in increments; unlike plan-driven, the functionality of these increments is not planned in advance but is decided **during** the development, **design and implementation are interleaved**.
- The system is developed as a **series of versions/increments** with **stakeholders involved** in version specification and evaluation; **frequent delivery of new versions for evaluation**, extensive tool support, minimal documentation - **focus on working code** - iteration planning, which has a shorter-term outlook
- The planning is based on user stories that reflect the desired features; the team reads/discusses the stories and ranks them in order of the amount of time they think it will take to implement the story. They are assigned 'effort points' reflecting their size/difficulty of implementation. The number of effort points per day gives an estimate of the team's velocity.
- **Task Allocation:** during the task planning stage, devs break down stories into development tasks and individual developer sign up for specific tasks. **Benefits:** whole team gets an overview of the tasks to be completed in an iteration, developers have a sense of ownership in these tasks
- **Software Delivery:** a software increment is always delivered at the end of each iteration; **Planning Difficulties:** (1) Agile planning is reliant on customer involvement and availability (2) representatives sometimes have to prioritize other work (3) some customers may be more familiar with traditional project plans
- **Applicability:** agile planning work well with **small, stable dev. teams** that can get together and discuss the stories - however, where teams are large and/or geographically distributed, it is practically impossible for everyone to be involved in the collaborative planning that is essential for agile project management.
##### Teamwork
- **Software Teams:** almost impossible for one person to complete non-trivial software projects; a cohesive group with team spirit, motivated by the success of the group as well as by their own personal goals in needed. Group interaction is a key determinant of group performance.
- Members should consider the group to be more important than any individual in it. The advantages of a cohesive group are: (1) group quality standards can be developed by the group members (2) team members learn from each other and get to know each other's work; inhibitions caused by ignorance are reduced (3) knowledge is shared; continuity can be maintained if a group member leaves (4) refactoring and continual improvement is encouraged; group members work collectively to deliver high quality results and fix problems, irrespective of the individuals who originally created the design or program
- Team spirit promotes inclusivity, encouragement, investment, benefits, getting to know each other, and social fun.
- **Team Models:** Chief Programmer Team (CPT) - hierarchical; Matrix Management (MM) - assembly line, linear; Self-Directed Work Teams (SDWT) - no specific structure
- **CPT** - 5-10 programmers led by a chief programmer, all supervised by a manager, all members active throughout development, one or two programmers responsible for software QA. **Advantages:** established chain of command, easy accountability. **Disadvantages:** success dependent upon competence of chief programmer, non-specialist programmers for each task. Good for projects where requirements are clearly defined and requirements can easily be divided into tasks, mostly applicable for plan-driven approach
- **MM:** Each member of the group has a specialized role, only remains in the group when his services are needed, members may be moved to other projects when their assigned tasks are completed. **Advantages:** matrix assures that projects get specially trained people in all activities. **Disadvantages:** difficult to have a good schedule once delays are induced, lot of communication and lack of accountability. Good for companies developing multiple projects simultaneously and each phase of these projects need specialized people.
- **SDWT:** no technical leader, external management or matrix groupings; teams empowered to conduct all activities like hiring, planning, scheduling, tracking, rewarding, etc. **Advantages:** good cohesiveness between team members, minimum external influence. **Disadvantages:** difficult to track progress. Good for projects where requirements aren't clearly defined, specifically R&D.
- MOI model of leadership: **Motivation** - the ability to encourage (by push or pull) technical people to produce to their best ability; **Organization:** the ability to mold existing processes (or invent new ones) that will enable the initial concept to be translated into a final product; **Ideas or Innovation:** the ability to encourage people to create and feel creative even when they must work within established bounds
- **Team effectiveness:** the people in the group (team composition) - diverse and specialized; the group organization - individuals can contribute to the best of their abilities; technical and managerial communications - good communication between team members and stakeholders is essential.
- **Composition:** the following factors must be considered when selecting a team structure - the difficulty of the problem, the size of the resultant program(s), the time that the team will stay together, the modularity of the problem, the required quality/reliability of the system to be built, the rigidity of the delivery date, the degree of sociability required for the project
- Groups composed of similar members can be problematic: task-oriented - everyone wants to do their own thing; self-oriented - everyone wants to be the boss; interaction-oriented - everyone is chatting too much → an effective group has a balance
##### Software Process Models
- A **process model** is a structured set of activities required to develop a software system - the universal activities involve **specification**, **design** and **implementation**, **validation**, and **evolution**. A software process model is an abstract representation of a process - it presents how different process activities are organized for a given process model.
- **Waterfall** - models where all of the process activities are planned in advance, and progress is measured against this plan (Linear Process Models - Waterfall; Linear Process Models w/ feedback - V-Model; Evolutionary Process Models - Prototyping, Spiral); **Incremental** - planning is incremental, and it is easier to change the process to reflect changing customer requirements (Incremental Model; XP; Scrum; Kanban). In practice, most process models use elements of both - they bring order to the software development process with the intention of producing high-quality products on time and within budget.
##### Waterfall Software Process Models
- Requirements Analysis and Definition → System and Software Design → Implementation and Unit Testing → Integration and System Testing → Operation and Maintenance; in principle, one phase has to be completed before moving onto the next phase. **Problems:** inflexible partitioning of the project makes it difficult to respond to changing customer requirements. This model is good if a large system is developed at several sites. In those circumstances, the plan-driven nature of the waterfall model helps coordinate the work.
- **Prototyping Variation:** (Prototyping Section connected to Requirements Definition/System and Software Design) stakeholders can look at the prototype, and several iterations can be used to refine the design and requirements
- **V-Model:** Requirements Definition → System Analysis → Software Design → Module Design → Coding → Unit Testing → Integration Testing → System Testing → Validation Testing, with Coding at the bottom of the V. Adds flexibility with feedback loops.
##### Incremental Software Process Models
- **Incremental Model:** (1) Develop an initial version (2) get stakeholder feedback (3) evolve into the next version (iteration) (4) repeat; specification, development, and validation are interleaved. **Benefits:** cost of accommodating changing customer requirements is reduced - amount of redoing is much less than waterfall; easier to get customer feedback on work; more rapid delivery and deployment of useful software to the customer is possible. No reduced cost of development. **Problems:** the process is not visible, and system structure tends to degrade as new increments are added.
##### Agile Process Models
- Requirements for many small/medium size software systems increase, and they change because of changes in team members, in software being built, and because of new tech.
- **Agile Manifesto:** (1) Individuals and interactions over processes and tools (2) working software over comprehensive documentation (3) customer collaboration over contract negotiation (4) responding to change over following a plan
- The aim of agile methods is to reduce overheads in the software process (e.g. by limiting documentation) and to be able to respond quickly to changing requirements without excessive rework. **Principles:** customer involvement, incremental delivery, people not process, embrace change, maintain simplicity
- **Applicability:** product development for a small/medium-sized product for sale, custom system development within an organization
- **XP** - most widely used agile process: new versions may be built several times per day, increments are delivered to customers every 2 week, all test must be run for every build and the build is only accepted if test run successfully. **Planning:** begins with the creation of "user stories"; team assesses each story and assigns a cost, groups them for a deliverable increment, and a commitment is made on delivery date. **Design:** simple designs (CRC cards), keep is simple, suggest the creation of spike solutions (prototypes), encourages refactoring. **Coding:** pair programming (1 codes, 1 reviews, doesn't speed up but improves quality), unit testing before coding commences, continuous integration, iterative refactoring, collective ownership; **Testing:** acceptance testing is defined by the customer and executed to assess customer visible functionality, unit testing is execute daily; **Release:** software increment, project velocity computed
- **User Stories for Requirements:** a customer/user is part of the XP team and is responsible for making decisions on requirements. Stories are written on cards and the development team breaks them down into implementation tasks. The customer chooses the stories for inclusion in the next release based on their priorities and the schedule estimates. 
- **Practices:** incremental planning, small releases, simple design, test-first development, refactoring, pair programming, collective ownership, continuous integration, sustainable pace, on-site customer. **Problems:** can be difficult to keep the interest of customers who are involved, team members may be unsuited to intense involvement, prioritizing changes can be difficult when there are multiple stakeholders, maintaining simplicity requires extra work.
- **Scrum:** an agile method that focuses on managing iterative rather than specific agile practices - 3 phases: **initial phase** - an outline planning phase where general objectives for the project and software architecture design is done; **series of sprint cycles** - each cycle develops an increment; **project closure phase** - wraps up the project, completes required documentation, and assesses the lessons learned from the project
- **Terminology:** Development team, Potentially Shippable Product Increment, Product Backlog, Product Owner, Scrum, ScrumMaster (no project manager) Spring, Velocity
- **Sprint Cycle:** usually 2-4 weeks, starting point for planning is in the product backlog, which is the list of work to be done on the project. Selection phase involves all of the project team who work with the customer to select the features and functionality from the product backlog to be developed during the sprint. Once these are agreed, the team organizes themselves to develop the software - the team is then isolated from the customer and the organization, with all communications channeled through the 'ScrumMaster', whose role is to protect the dev. team from external distractions. At the end of the sprint, the work done is reviewed and presented to stakeholders.
- **Teamwork:** the ScrumMaster is a facilitator who arranges daily scrums (meetings), tracks the backlog, records decisions, measures progress and communicates with customer/management outside the team. scrums allow team members to share info, describe their progress, problems that have arisen and what is planned for the following day.
- **Benefits:** The product is broken down into a set of manageable and understandable chunks; Unstable requirements don't hold up progress; the whole team has visibility of everything and consequently team communication is improved; customers see on-time delivery of increments and gain feedback on how the product works; Trust between customers and developers is established and a positive culture is created in which everyone expects the project to succeed.
##### Process Improvement and Maturity
- the existence of a software process model is no guarantee that the software will meet any expectations - they must be coupled with solid software engineering practice. Many companies have turned to software process improvement as a way of enhancing their software quality, reducing costs/accelerating their dev. process.
- **Process maturity approach:** focuses on improving process and project management and introducing good software engineering practice; **agile approach:** focuses on iterative development and reduction of overheads
- **Process Measurement:** measure one or more attributes of the software process/product. These form a baseline for judgement; **Process Analysis:** process weaknesses and bottlenecks are identified. Process models that describe the process may be developed; **Process Change:** process changes are proposed to address weaknesses.
- **Process Measurement:** whenever possible, quantitative data should be collected, which is very difficult w/o clearly defined process standard; measurements should be used to assess process improvements, but makes sure to have the organization objectives as the driver for the improvement, not the measurements; **Examples:** time taken for process activities to be completed, resources required, number of occurrences of a particular event
- **Capability Maturity Levels:** application of process management and quality improvement concepts to software dev. and maintenance.
- **CMMI Levels:** Level 1: Initial - essentially uncontrolled, **Characteristics:** chaotic, unpredictable cost, schedule, and quality performance, success depends on competence and heroics of individuals, **Needed Actions:** planning, performance tracking, change control, commitment management, quality assurance; Level 2: Repeatable (Managed) - Product management procedures defined and used, **Characteristics:** intuitive, cost and quality highly variable, reasonable control of schedules, informal and ad hoc process methods and procedures, process capability can be summarized as discipline because project planning and tracking are stable and earlier successes can be repeated, **Needed Actions:** develop process standards and definitions, assign process resources, establish methods; Level 3: Defined - Process management procedures and strategies defined and used, **Characteristics:** reliable costs and schedules, improving but unpredictable quality performance, process capability summarized as standard and consistent due to stable and repeatable software engineering and management activities, **Needed Actions:** process measurements, quantitative quality goals, plans, tracking; Level 4: Quantitatively Managed - Quality management strategies defined and used, **Characteristics:** reliable statistical control over product quality, process capability can be summarized as being quantifiable and predictable because the process is measured and operates within measurable limits, **Needed Actions:** quantitative productivity plans and tracking, instrumented process environment, economically justified tech investments; Level 5: Optimizing - Process improvement strategies defined and used, **Characteristics:** quantitative basis for continued capital investment in process automations and improvement, process capability is continuously improving, **Needed Actions:** continued emphasis on process measurement and process methods for error prevention.
##### Software Process Activities
- real software processes are interleaved sequences of technical, collaborative and managerial activities with the overall goal of specifying, designing, implementing, and testing a software system: Specification (requirement engineering), Development (design and implementation), Validation, Evolution
- **Software Specification and Requirement Engineering:** *Requirements Elicitation and Analysis*: what do the system stakeholders require or expect from the system? *Requirements Specification*: defining the requirements in detail. *Requirements Validation*: checking the validity of the requirements. System Descriptions: UI Walkthrough, Deployment Diagram; User and System Requirements: User Stories, Use Cases/Use Case Diagrams, SRS Document.
- **Design and Implementation:** **Inputs**: *Requirements Specification*: tells the major functional/nonfunctional requirements; *Data Description:* what kind of data is needed in our system? How will it be interacted with? How is data structured to satisfy those interactions?; *Platform Information*: How are we going to deploy the software in the runtime environment - OS, protocols, etc. **Activities:** *Architectural Design* - Identify the overall structure of they system, the principal components (subsystems/modules) their relationships and how they are distributes. *Interface Design* (protocols, UI, etc.) - where you define the interfaces between the principal components, their 'relationships'. *Component Design* (class diagrams): How each component is designed, identifying objects, reusable components.*Database Design*: what database system is being used? Where the system data structures are designed and their representations. **Outputs:** *System Architecture:* deployment diagram, interaction diagram; *Database Specification:* data entities, attributes in the data structures, relationships between entities, how is data stored, E-R Diagram; *Interface Specification:* how sill the UI and other interfaces look? Component Diagram. *Component Specification*: class diagram.
- **Verification and Validation:** system **conforms to its specification** and **meets the requirements of the system customer**. Involves **checking and review processes** and **system testing** (executing with test cases derived from the specification of the real data to be processed by the system). **Component testing (JUnit, Nuint, DBunit), System Testing (state diagrams, sequence diagrams, interaction diagrams), Customer/Acceptance Testing (use-case based testing, random testing)**
##### Software Requirement Engineering
- Potential stakeholders: end users, system managers, software engineers/developers, system owners, external stakeholders, project managers, customers, sales people
- **Functional Requirements:** statements of functionalities that the system should provide, how the system should react to particular inputs and how the system should behave in particular situations; basically, what the system should and shouldn't do. *User Requirements:* high-level statements of what the system should do; *System Requirements:* should describe the system features in detail, what and how. 
- **Non-functional Requirements:** constraints on the functionalities offered by the system such as timing constraints, performance constraints, regulations, etc. Often apply to the system as a whole rather than individual features or services.
	- **Product requirements** - specify that the product must behave in a particular way e.g. execution speed, reliability, etc. *Usability Requirements* - how easy it is to use/learn the system; *Efficiency Requirements* - time and space performance; *Dependability Requirements* - how robust and reliable; *Security Requirements:* how secure
	- **Organizational requirements** - are a consequence of organizational policies and procedures e.g. process standards used, implementation requirements, etc. *Environmental Requirements*; *Operation Requirements*; *Development Requirements*
	- **External requirements** - arise from factors which are external to the system and its development process e.g. interoperability requirements, legislative requirements, etc. *Regulatory Requirements*; *Ethical Requirements*; *Legislative Requirements*
- Problems arise when functional requirements aren't precisely stated. Ambiguous requirements may be interpreted in different ways be developers and users. Use feedback to solve this. 
- In principle, requirements should be both complete (include descriptions of all facilities required) and consistent (no conflicts or contradictions in the descriptions of the system facilities)
- **Implementation**: non-functional requirements may affect overall system architecture rather than the individual components. A single non-functional requirement may generate a number of related functional requirements.
- **Metrics:** *Speed:* transactions/second, user/event response time, screen refresh time; *Size:* Mbytes, number of ROM chips; *Ease of Use:* training time, number of help frames; *Reliability:* mean time to failure, probability of unavailability; *Robustness:* time to restart after failure, percentage of event causing failure, probability of data corruption on failure; *Portability:* percentage of target dependent statements, number of target systems
- **ISO-25010 Software Quality Framework:** Functionality, Compatibility, Reliability, Usability, Efficiency, Maintainability, Portability, Security; **Software quality represents both functional and non-functional requirements.**
- **Requirements Elicitation:** working with system stakeholders to find out about the application domain, the services that the system should provide, required system performance, hardware constraints, etc. **Problems:** stakeholders don't know what they really want, they express requirements in their own terms, different stakeholders may have conflicting requirements, organizational and political factors, and changing requirements.
- **Ways of Writing a SRS:** natural language, structured natural language, design description languages, graphical notations, or mathematical specifications.
- **Use-Case Based Representation of Requirements:** *Use-Cases* - representation of a distinct functionality of a system, a major use, should represent a verb. *Actors:* an entity that performs key roles in the given system, interacts with a use case. *Use-Case Diagram:* shows how actors interact with use-cases, relationship among actors and relationship among use-cases. *Use-Case Scenarios:* a narrative that describes activities associated with the use-case
- **Use-Case Diagram Relationships:** *Includes/Uses:* when a use-case is depicted as using the functionality of another use-case in a diagram. *Extends:* the child-user case adds to the existing functionality and characteristics of the parent use--case. "may involve the usage of", the parent is the origin of the arrow. *Generalization:* the child use-case is the 'subclass' of the parent use-case, which is the end of the arrow.
##### Fundamentals of Object-Oriented Analysis and Design
- OOP concerns the design of software modules of a system as a collection of objects, where an object represents a collection of related **functionality** and **data**. An object is a computational entity that encapsulates fields (state) and methods (behavior).
- **Foundations of Software Design:** (1) Abstraction - data and procedural abstraction (2) Modularity - how well objects abstract underlying data and procedures so that each object is as independent as possible (3) Architecture - overall structure of the software system, organization of objects in the design and their behavior at runtime
- An encapsulated (abstracted) object can be though of as a *black box* - its inner working are hidden from the client, who can only invoke the interface methods of the object. OOP facilitates **Encapsulation and information hiding**, which reduces the likelihood of "side effects", limits the global impact of local design decisions, emphasizes communication through controlled interfaces, discourages the use of global data, results in higher quality software.
##### Object-Oriented Analysis and Modeling
- **Approach:** (1) Identify Actors and Use Cases (2) Develop each use case diagram (3) Develop each use case scenario (4) Identify objects (5) establish high-level object relationships (CRC)
- **Categorization of Classes:** *Boundary* - classes that interact with entities outside of the system (UI, external database, API, OS, etc.), serves as an interface, reduces complexity, helps maintainability. *Entity* - classes that contain all the data, procedures, algorithms, etc. All the computations + internal database operations, independent of the system's interfaces, corresponds to real-world entities that the system manipulates, represents computations, algorithms, and data, "Heart of the system". *Control* - classes that interface between boundary and entity classes, responsible for receiving/handling system events, encapsulating behavior of use case (often one control class per each use case), 
- **External Entities:** other systems, devices, people, etc. that produce or consume information to be used by a computer-based system. **Things:** reports, displays, letters, signals, etc. that are part of the information domain for the problem. **Events:** significant actions that occur within the context of system operation.
- **Analysis Classes:** Roles played by people who interact with the system, organizational units that are relevant to an application, places that establish the context of the problem and the overall function of the system, structures that define a class of objects or related classes of objects 
- **Defining Operations:** manipulate data in some way, perform a computation, inquire about the state of an object, monitor an object for the occurrence of a controlling event
- **CRC Diagrams and Class Diagram:** former represents the responsibilities of each class and other collaborating classes to achieve those functionalities. Latter describe static structure of the system, objects/classes including attributes and operations, and relationship among them.
- **CRC Diagrams:** like an index card set where each index card has three portions: *Class:* name of the class and a description of the class indicating main functionality, *Responsibility:* lists main functionalities of the class, *Collaborator:* collaborator classes for each functionality
- Use-case diagram represents the high-level dynamic view of the system. It depicts main functionalities, their relationship, and entities (actors) that invoke these functionalities. Use-case diagram doesn't show how functionalities will be implemented.
##### Documenting Software Analysis
- Class relationships can be: **structural** - objects share data and methods (association - more loosely coupled connections, aggregation - "has a" relationship, composition - "whole to part" relationship, generalization (inheritance)), or **non-structural** (dependency) - objects don't share attributes or methods; one calls the other.
##### Design Patterns
- represent **reusable solutions** to commonly occurring problems in software design; are proven solutions under certain requirements; **Benefits** - improved modularity, better testability, assurance of software quality attributes
- **Creational Design Patterns:** provide different techniques to instantiate and create objects instances efficiently, improves factor like: runtime resource usage, modularity/modifiability, testability
	- **Factory:** rather than the client creating different types of object instances, it uses the service of an object factory to request the type of object instance needed
	- **Abstract Factory:** provides an interface to create a group of individual factories with common theme without specifying their concrete classes
	- **Prototype:** provides a prototype of the object (initial setup) that can be copied/cloned, removes the need of object initialization process repeatedly
	- **Singleton:** class in which only single instance is possible
	- **Builder:** aims to separate the construction of a complex object from its representation, i.e. StringBuilder
	- **Object Pool:** has a collection of object instances where clients can request them, used where cost of initialization is very high so there is a limited number of instances
- **Behavioral Design Patterns:** about identifying common communication patterns between objects; provide a body of knowledge that represents **how objects interact with each other**. Maintain modularity while establishing communication
	- **Chain of Responsibility:** way of passing requests among multiple participating objects in the system which the client isn't aware of
	- **Observer:** change in one object will be notified to other relevant objects. Notification mechanisms vary in different programming languages
	- **Strategy:** some applications require different algorithms whose execution is determined at runtime. This pattern implements a collection of algorithms as objects so that the application can select the suitable object at runtime
	- **Iterator:** sequentially access items in the collection w/o using the implementation of the collection
	- **State:** state of object is represented as another object. As the state of the object changes, state behavior of the object-implementation object is called
	- **Visitor:** used when we have to perform an operation on a group of similar kinds of objects; move operation logic from the objects to another class
	- **Mediator:** communication bus that controls how different objects interact with each other, reduces the coupling among objects in the expense of developing a separate mediator object
##### Software Architecture
- **Architectural Design:** concerned with designing the overall structure of the system - 'the organization'. Provides the critical link between requirements engineering and the design, as it identifies the main structural components in a system and the relationships between them.
- In the small, it is concerned with the architecture of individual programs, the way that an individual program is decomposed into components. In the large, it is concerned with the architecture of complex enterprise systems that include other systems, programs, and components
- **Architectural Views:** each architectural model only shows one view/perspective of the system - for both design and documentation, you usually need to present multiple views of the software architecture. **Logical View:** shows the key abstractions in the system as objects - class diagrams *|* **Process View:** shows how, at run-time, the system is composed of interacting processes - sequence diagrams, interaction diagrams *|* **Development View:** shows how the software is decomposed for development - component bills *|* **Physical View:** shows the system hardware and how software components are distributed across the processors in the system - deployment diagrams *|* use-cases and scenarios can be thought of as an extra view as well.
- **Advantages:** stakeholder communication, system analysis, large-scale reuse
- **Architectural Representations:** *simple, informal block diagrams* showing entities and relationships - have been criticized because they lack semantics, don't show types of relationships between entities nor visible properties, and are very abstract - useful for communication w/ stakeholders and for project planning **|** *C4 Approach:* L1 - Context: the highest level of abstraction. Shows the entire system as a single box and describes who and what interacts with the system from the outside. L2 - Containers: individual components of our software that can be executed and deployed; need to be running for the whole system to operate. L3 - Components: zoom in to each container, and see the individual modules. L4 - Code: zoom in to each module and see the implementation Deployment View: Hardware and Software for the containers/components. "a component is a grouping of related functionality encapsulated behind a well-defined interface."
- **Design Decisions:** Is there a generic application architecture that can act as a template for the system that is being designed? How will the system be distributed across hardware cores/processors? What architectural patterns or styles might be used? What strategy will be used to control the operation of the components in the system? How should the architecture of the system be documented? What architectural organization is best for delivering the non-functional requirements of the system? How will the structural components in the system be decomposed into sub-components? What will be the fundamental approach used to structure the system?
- **Architecture and System Characteristics:** Performance: localize critical operations and minimize communications. Use large rather than fine-grain components **|** Security: use a layered architecture with critical assets in the inner layers **|** Safety: localize safety-critical features in a small number of sub-systems **|** Availability: include redundant components/mechanisms for fault tolerance **|** Maintainability: use fine-grain, replaceable components - coupling: more equals more connections (Less); cohesion: more equals more independence from other modules (More)
- **Architectural Patterns:** similar to design patterns, used to represent, share and reuse knowledge.
	- **Layered:** organizes the system into a set of layers (or abstract machines), each of which providing a set of services. Supports the incremental development of subsystems in different layers; when a layer interface changes, only the adjacent layers are affected. **Applicability:** general-purpose, large and complex systems, flexibility and scalability. **Advantages:** modularity, separation of concerns, layer isolation, code reusability, ease of testing. **Disadvantages:** performance overhead, tight coupling, scalability challenges, monolithic tendency
	- **Client-Server:** distributed system model which shows how data and processing is distributed across a range of components - can be implemented on a single computer. Client initiates requests to the server for services/resources, server processes requests and sends responses back to clients. **Applicability:** web applications/websites, email systems, file sharing applications, etc. **Advantages:** servers can be distributed across a network; general functionality can be available to all clients and doesn't need to be implemented by all services, centralized data storage and management, scalability. **Disadvantages:** each server is a single point of failure, susceptible to DoS attacks or server failure, performance/management problems, servers can be expensive to purchase/manage
	- **Model-View-Controller (MVC):** separates presentation and interaction from the system data. The Model manages the system data and associated operations, the View defines and manages how the data is presented to the user, the Controller manages user interaction and passes them to the View and the Model.  **Applicability:** web applications, complex applications, UI development, test-driven development, SEO-friendly, multi-view applications, used when there are multiple ways to view and interact with data. Also used when the future requirements for interaction and presentation of data are unknown. **Advantages:** allows data to change independently of its representation and vice versa. Separation of concerns, multiple views. **Disadvantages:** complexity, learning curve, potential performance overhead, frequent updates, scalability limitations
- **Service-Oriented:** services are loosely coupled, reusable components that encapsulate discrete functionality; a web service is a service that is accessed using standard Internet/XML-based protocols. Services are platform and implementation-language independent. **Applicability:** enterprise application integration, cloud-based/web applications, etc. **Advantages:** services can be offered by any service provider, allowing for multi-service integration for application development. The service provide makes info about the service public so that any authorized user can use the service. Applications can delay the binding of services until they are deployed or until execution, which means that applications can be reactive and adapt their operation to cope with changes to their execution environment
- two types of web services: SOAP (Simple Object Access Protocol, runs on top of HTTP) and REST (directly work on HTTP, less payload)
##### Information Management Systems
- a general term for software systems designed to facilitate the storage, organization and retrieval of information in a variety of formats and makes it easy for people to access the store information
- IMS is sometimes used synonymously with Database Management System (DBMS) 
- **Features:** information must be collected and stored, manageable, and accessible.
- **File System vs DBMS:** files systems are simpler and more suitable for basic file storage, while DBMSs offer more advanced features for managing large-scale, structure data in complex environments. 
- In a DBMS, data is generally stored in either a hierarchical form or a navigational form. **RDBMS:** a special type of DBMS which is based on the relational model, but not every DBMS must be relational. In a RDBMS, the tables will have an identifier called a *primary key*. Data values will be stored in the form of tables, and the relationships between these values will be stored in the form of a table as well.
- **Data Model:** logical structure of a database, describes the design of the database to reflect entities, attributes, relationship among data, constraints, etc. *object-based logical models* - describe data at the conceptual and view levels, ER diagram. *record-based logical models* - specify logical structure of database w/ records, fields, and attributes, Relational Model.
- **Database Design Process:** (1) Requirements Collection & Analysis (2) Conceptual Design (DBMS independent) - ER Model (3) Choice of DBMS (4) Logical Design (5) Physical Design (6) Implementation
##### Databases
- an ordered collection of info from which a computer program can quickly access info.
- **relation is a table** - so, data is stored in a tabular format. Each **row** in a database is called a **record**, which is a single complete set of related information. Each **column** in a table is called a **field**, which are the individual categories of info stored in a record.
- **SQL** stands for Structured Query Language, a programming language for relational databases. Consists of many types of statements, which are sometimes called (sub)languages. *data definition* - design and modify database schema; *data manipulation* - store and retrieve data from database
- **Data Definition Language:** 
```
-- Create a new table: CREATE TABLE table_name ( column1 datatype, column2 datatype, ... ); 
-- Create a new database: CREATE DATABASE database_name;
-- Add a new column: ALTER TABLE table_name ADD column_name datatype; 
-- Modify column datatype: ALTER TABLE table_name MODIFY column_name new_datatype; 
-- Drop a column: ALTER TABLE table_name DROP COLUMN column_name;
-- Delete a table: DROP TABLE table_name; 
-- Delete a database: DROP DATABASE database_name;
-- Remove all data from a table: TRUNCATE TABLE table_name;
```
- **Data Manipulation Language:**
```
-- Basic select: SELECT column1, column2 FROM table_name; 
-- Select all columns: SELECT * FROM table_name; 
-- Select with condition: SELECT column1, column2 FROM table_name WHERE condition; 
-- Select distinct values: SELECT DISTINCT column1 FROM table_name;
SELECT first_Name from PersonInfo ORDER BY Age;
SELECT first_Name from PersonInfo where annual_Income > 50000 AND age > 50 ORDER BY Age;
SELECT AVG(Age) from PersonInfo;
SELECT MAX(annual_Income) from PersonInfo;
-- Insert a single row: INSERT INTO table_name (column1, column2) VALUES (value1, value2); 
-- Insert multiple rows: INSERT INTO table_name (column1, column2) VALUES (value1, value2), (value3, value4);
-- Update data in a table: UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;
-- Delete rows from a table: DELETE FROM table_name WHERE condition;
```
- Primary key is not mandatory if duplicates are ok. A primary key uniquely identifies each record in a database table, must contain unique values, and cannot contain NULL values. Each table can have one or more primary keys. If you have multiple tables and they share the same primary key, one primary key can be a foreign key, which models a one-to-one relationship
```
CREATE TABLE PersonInfo (...); Primary Key(SSN);
```
- One-to-one relationships exist between two tables when one table contains exactly one record for each record in the primary table. Information in the table in a one-to-one relationship can be placed within a single table. This relationship makes information in one of the tables confidential and only accessible by certain individuals
- One-to-many relationships exist when one record in a primary table has many related records in a related table. Breaking tables into multiple related tables to reduce redundant and duplicate information is called **normalization**, which provides more efficiency and less redundancy.

```
CREATE TABLE languages(
employee_id INT NOT NULL,
language VARCHAR(32),
FOREIGN KEY (employee_id)
REFERENCES
Employees(employee_id)
)
```

```
SELECT e.first_name, p.pay_rate
FROM Employee e, Payroll p
WHERE e.employee_id = p.employee_id
AND p.pay_rate>30.00
```
##### Entity-Relationship Diagrams
- a graphical approach to database design; a high-level data model that defines data elements and their relationship. An entity is something definable within a system, such as a person/role, object, concept, or event. 
- **Data Entity and Attributes:** *Entity* is an object, represented as Rectangle. *Attribute* describes the property of an entity, represented as Oval. A primary key attribute uniquely identifies an entity from an entity set, with text underlined. A composite attribute is a combination of other attributes. A multivalued attribute can hold multiple values, represented with double ovals. A derived attributed is one whose value is dynamic and derived from another attribute, represented by a dashed oval. *Relationship* is represented by a Diamond.  
##### Software Testing
- is intended to show that a program does what it is intended to do and to discover program defects before it is put into use. When you test software, you execute a program using artificial/real data and check the results for errors, anomalies/information about the program's non-functional attributes. Testing can reveal the presence of errors, NOT their absence.
- Testing in part of a more general V&V process, which also includes static validation techniques. The goals are to demonstrate to the developer and the customer that the software meets its requirements, and to discover situations in which the behavior of the software is incorrect, undesirable, or doesn't conform to its specification.
- Defect testing is concerned with rooting out undesirable system behavior such as system crashes, unwanted interactions with other systems, incorrect computations and data corruption.
- **Developer:** understands the system, will test "gently", driven by "delivery"; **Independent Tester:** must learn about the system, will attempt to break it and is driven by quality
- **Verification** - refers to the set of activities that ensure that software correctly implements a specific function: "are we building the product right?"; **Validation** - refers to a different set of activities that ensure that the software that has been built is traceable to customer requirements: "are we building the right product?"
- **Testing Strategies:** *unit testing* - the smallest possible unit in a system (function, object, module, etc.); *integration testing* - integrate the objects into one module and test that, repeat for bigger systems as well; *system testing* - how do we test the integrated testing; *validation testing* - functionality testing, use-case
- **Testing Strategies:** *Blackbox Testing:* Equivalent Partitioning, Boundary Value Analysis, Use-case based, Exploratory, Model-based, Input → Output; *Whitebox Testing:* Control Flow, Dataflow, Slicing, Decision to Decision
- In addition to testing, inspections and reviews are two other commonly used software QA techniques. **Inspections** involve people examining the source representation with the aim of discovering anomalies and defects, and they don't require execution. They may be applied to any representation of the system (requirements, design, configuration data, test data, etc.) and have shown to be effective. **Reviews** fall under the categories of Management, Technical, Inspections, Walkthroughs, and Audits. *Management:* a systematic evaluation of a software acquisition, supply, development, operation, or maintenance process performed by or on behalf of management that monitors progress, determines the status of plans and schedules, confirms requirements and their system allocation, or evaluates the effectiveness of management approaches used to achieve fitness for purpose. *Technical:* evaluate the product to determine its suitability for its intended use. Identify discrepancies from specification and standards. *Inspections:* evaluation technique in which software requirements, design, or code are examined in detail by person or group other than the author. *Walkthrough:* the author of the code formally presents the requirements, design, or code to a small group of reviewers. *Audit:* independent examination of a software product, process, or set of software processes to assess compliance with specification, standards, contractual agreements, or other criteria.
- Some things to look out for are duplicated code, long methods, large classes, long parameter lists, and temporary fields.
- **Advantages:** during testing, errors can mask other errors - because inspection is a static process, you don't have to be concerned with interactions between errors. Incomplete versions of a system can be inspected w/o additional costs, and an inspection can also consider broader quality attributes like maintainability, portability, and compliance w/ standards. **Inspections can check conformance w/ a specification but not conformance with the customer's real requirements. They also cannot check non-functional characteristics such as performance, usability, etc.**
- **Inspections are concerned with analysis of the static system representation, while testing is concerned with exercising and observing product behavior - static vs dynamic verification**
- **Blackbox Testing:** don't know what is inside, only know how to run the system, and types of inputs/outputs
	- **Equivalent Partitioning:** divides the input domain of a program into classes of data from which test cases can be derived. It strives to define a test case that uncovers classes of errors, and reduces the total number of testcases. **Guidelines:** if input specifies a range - one valid values, two invalid values; if input requires specific value - one valid value, two invalid values; if input specifies a member of a set - one valid, one invalid; if input condition if Boolean - one valid, one invalid
	- **Boundary Value Analysis:** a greater number of errors occur at the boundaries of the input domain rather than in the "center". This approach complements equivalence partitioning: if an input condition specifies a range bounded by values a and b, test cases should be the values a and b, and just above and below a and b.
	- **Use-Case Based Testing:** use-case basic flow and alternative flows provide sequence of events and actions related to the use-case and system output. Thus, use-case scenarios provide a set of steps in testing the application.
- **White-Box Testing:** *Unit Testing:* the process of testing individual components in isolation; a defect testing process. Units may be individual functions/methods within an object, object classes with several attributes and methods, or composite components w/ defined interfaces used to access their functionality. *Object Class Testing:* complete coverage of a class involves (1) testing all operations associated w/ an object (2) setting and interrogating all object attributes (3) exercising the object in all possible states. Inheritance makes it more difficult to design object class tests as the info to be tested isn't localized. Using a state model, identify sequences of state transitions to be tested and the event sequences to cause these transitions, i.e. Shutdown → Running → Shutdown
- **Basic Approach:** involves developing test cases and testing the software system based on the code. Thus, the test has access to the code and is knowledgeable about the programming language used to develop the software. Code-based testing focuses on covering the code in various angles - test coverage.
- **Code-based Testing Strategies:** (1) Statement coverage (2) Basic path testing (control flow coverage) (3) Decision-to-Decision testing (4) Dataflow coverage (5) Condition testing (6) Code-based risk assessments (complexity, object-oriented matrices, etc.)
- If the graph has one source node and one sink node, then we can apply the equation for cyclomatic complexity: Edges - Nodes + 2 = number of independent paths. 
##### JUnit
- a single framework to write repeatable tests, an instance of the xUnit architecture for unit testing frameworks written by Kent Beck and Erick Gamma
```
-- Basic Annotations
@Test public void testMethod() {}
@BeforeEach public void setUp() {}
@AfterEach public void tearDown() {}
@BeforeAll public static void setUpClass() {} 
@AfterAll public static void tearDownClass() {} 
@Disabled public void disabledTest() {}

-- Assertions
assertEquals(expected, actual);
assertNotEquals(unexpected, actual);
assertTrue(condition);
assertFalse(condition);
assertNull(object);
assertNotNull(object);
assertSame(expected, actual);
assertNotSame(unexpected, actual);
assertThrows(ExpectedException.class, () -> { // Code that should throw exception }); 
assertAll("grouped assertions", () -> assertEquals(expected1, actual1), () -> assertEquals(expected2, actual2) );
fail("Fail message");
```
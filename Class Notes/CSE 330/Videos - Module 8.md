202406181916
Meta Tags: #class
Tags: [[OS]]

# Videos - Module 8

## Introduction of Memory and Virtual Memory

### Early Systems

- OS was a set of libraries
- OS sat in memory starting at physical address 0
- The rest was used by the running program

![[Pasted image 20240618191749.png]]

### Multiprogramming & Time Sharing

- OS makes sure each process is confined to its **own address space** in memory
- One naive implementation:
	- *base register* and *limit register* pair to set a range for address space; use base to point to start of the program in memory, use limit to define the bounds of the program

### The Address Space

- an easy-to-use abstraction of physical memory
- it is the running program's view of memory in the system
	- virtual address or logical address
	- physical address refers to those seen by the memory unit hardware
- the user program generates *logical* addresses; it never sees the real physical address
- the OS is the one that maps the logical address seen by the user program to the actual physical memory address

![[Pasted image 20240618192300.png]]

### High-Level Goals

- Transparency - user program behaves as if it has its own private physical memory
- Efficiency - space and time efficient memory virtualization, performance relies on hardware support
- Protection - isolated, user process shouldn't access or affect anything outside its own address space

**All the memory addresses you see are virtual**.

![[Pasted image 20240618192611.png]]

![[Pasted image 20240618192618.png]]

## Static Memory Relocation

How do we allocate the physical memory to the virtual memory address space?

### Static Relocation

**Idea**: rewrite each program before loading it into memory as a process; each rewrite uses different addresses and pointers (change jumps, loads, etc.)

**Disadvantages:** 
- low scalability - range of address space cannot be changed
- low flexibility - cannot shift address space in physical memory
- more effort to change and not general enough - implementation depends on hardware

## Dynamic Memory Relocation with Base

**Base:**
- **Idea:** translate virtual addresses to physical by adding an offset each time
- store base address in a base register
- each process has a different value in the base register when running

### Base Relocation

![[Pasted image 20240618193813.png]]

### Base Relocation Hardware

- Memory Management Unit (MMU) is a piece of hardware on the CPU chip which holds the base register value
- it performs simple addition to add logical address generated by CPU with base address to get the physical address


![[Pasted image 20240618193928.png]]

### Base-and-Bounds

- **Idea:** add bound register to avoid "overflow"
- 2 CPU registers
- Base register
- Bounds register
	- physical addr = virtual addr + base
- Protection: the hardware provides special instruction to modify the base and bounds register
	- allowing OS to change them when different processes run
	- Privileged (only in kernel mode)

### Code Sharing

**Idea:** make base/bounds for the code of several processes point to they same physical memory

Needs careful protection.

![[Pasted image 20240618194313.png]]

**Advantages:**
- fast and simple
- little bookkeeping overhead (2 registers)
**Disadvantages:**
- not flexible
- wastes memory for large memory addresses

- simple base-and-bounds program approach wastes a chunk of "free" space between stack and heap
- impossible to run a program when its entire address space is greater than the memory capacity

## Dynamic Relocation with Segmentation

### Segmentation

**Idea:** generalize base-and-bounds
- each base+bounds pair is a **segment**
- use different segments for heap and other memory collections
	- requires more registers
- resize segments as needed
- a segment is a contiguous portion of the address space
- a program is a collection of segments
- a segment can be a logical unit:
	- main program, procedure, function, object, local variable, global variable, common block, stack, heap, symbol table, data structure, etc.

### Logical View of Segmentation

![[Pasted image 20240618194742.png]]

### Segmentation Fault

a program trying to read or write an illegal memory location:

![[Pasted image 20240618194904.png]]

### Segmentation Architecture

- Logical address consists of a pair:
	- segment number, offset
- Segment table - maps 2D physical addresses. Each table entry has:
	- base - contains the starting physical address where the segments reside in memory
	- limit - specifies the length of the segment
- Segment-table base register (STBR) points to the segment table's location in memory
- Segment-table length register (STLR) indicates number of segments used by a process

![[Pasted image 20240618195132.png]]

### Example of Segmentation

![[Pasted image 20240618195157.png]]

### External Fragmentation

- As processes are loaded and removed from the main memory, the free memory is broken into small pieces
	- hole - block of available memory; holes of various size that are scattered throughout memory
- a new allocation request may have to be denied when there is no contiguous free memory with requested size
- the total free memory space may be much larger than the requested size!

![[Pasted image 20240618195337.png]]

### Memory Compaction

- Reduce external fragmentation by compaction
	- shuffle memory contents to place all free memory together in one large block
	- only possible if relocation is dynamic, and is done at execution time
	- must be careful about pending I/O before initiating compaction

### Dynamic Memory Allocation

- How to satisfy a request of size N from a list of free holes?
- Dynamic memory allocation (free-list management algorithms)
	- first-fit: allocate the first hole that is big enough
	- best-fit: allocate the smallest hole that is big enough
	- worst-fit: allocate the largest hold
	- next-fit: first-fit from the last allocation




---
# *References*
https://canvas.asu.edu/courses/187584/assignments/5154814?module_item_id=13536089
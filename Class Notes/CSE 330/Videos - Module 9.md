202406182041
Meta Tags: #class
Tags: [[OS]]

# Videos - Module 9

## Introduction of Paging

**Motivation:** segmentation is too **coarse-grained:**
- either waste space (external fragmentation) or
- copy memory often (compaction)

### Paging Scheme

- a memory management scheme that allows the physical address space of a process to be non-contiguous
- divide physical memory into fixed-sized blocks called frames
- divide logical memory into blocks of same size called pages
- flexible mapping (big overhead): any page can go to any free frame
- scalability: to run a program of size $n$ pages, need to fine $n$ free frames and load program; grow memory segment whenever we please!

![[Pasted image 20240618204607.png]]

### Addressing Basics

- For segmentation
	- high bits -> segment \#
	- low bits -> offset
- For paging
	- high bits -> page \#
	- low bits -> offset

Split the address into two parts of size l and r, then there are 2^l pages and 2^r bytes per page

This address is only the virtual memory, not the actual physical memory.

## Page Table Design

### Virtual → Physical Address Mapping

- We need a general mapping mechanism
- What data structure is good?
	- big array

![[Pasted image 20240618211358.png]]

PFN → physical frame number
VPN → virtual page number

### Page Table

A per-process data structure used to keep track of virtual page to physical frame mapping

Major role: store address translation

### Address Translation Scheme

Observe: the simple limit/relocation register pair mechanism is no longer sufficient

m-bit virtual address generated by CPU is divided into:
- Virtual Page Number (p) - used as an index into a page table which contains base address of each page in physical memory
- Page Offset (d) - combined with base address to define the physical memory address that is sent to the memory unit
Frame number (f)

![[Pasted image 20240618211703.png]]

### Free Frames

![[Pasted image 20240618211812.png]]

### More on Page Table

The page table data structure is kept in main memory

Each page table entry (PTE) holds the physical translation as well as other info.

Page-table base register (PTBR) points to the page table

Page-table length register (PTLR), if it exists, indicates the size of the page table

### PTE

The simplest form of a page table is a linear page table:
- array data structure
- OS indexes the array by VPN to find the desired PFN

## Introduction of Translation Lookaside Buffer (TLB)

### Paging Problems

- Page tables are too slow → TLB
- Page tables are too big

### Address Translation Steps

1. CPU gets virtual address
2. Extract VPN from VA (virtual address)
3. Calculate address of PTE
4. Fetch PTE (expensive)
5. Extract PFN
6. Build PA (physical address)
7. Fetch PA to register (expensive)

### Performance Problems

- A basic memory access protocol:
	- fetch the translation from in-memory page table
	- explicit load/store access on a memory address
- In this scheme, every data/instruction access requires two memory accesses, one for the page table and one for the data/instruction
- Too much performance overhead!

### Speeding up Translation

- This can be solved by the use of a special fast-lookup hardware cache called the TLB, which is part of the memory-management unit (MMU)
- For each virtual memory reference, hardware first checks the TLB to see if the desired translation is held therein


1. Extract VPN from VA
2. Check if TLB holds the translation
3. If it is a TLB hit – extract PFN from the TLB entry, concatenate it onto the offset to form the PA
4. If it is a TLB miss – access page table to get the translation, update the TLB entry with the translation

## TLB Design Details

### TLB Content

Some entries are wired down or reserved for permanently valid translations.

TLB is a **fully associative cache**:
- any given translation can be anywhere in the TLB
- hardware searches entire TLB in parallel to find a match

Typical TLB entry:
```
VPN | PFN | other bits
```

### Paging Hardware w/ TLB

![[Pasted image 20240625182227.png]]

### TLB Issue - Context Switch

- TLB only contains translations valid for the currently running process
- Switching from one process to another requires OS or hardware to do more work

How does the OS distinguish which entry is for which process?

![[Pasted image 20240625182455.png]]

#### Flush

- OS flushes the whole TLB on context switch
- sets all valid bits to 0
- high overhead, especially if context switches are frequent

#### ASID

- Some hardware systems provide an address space identifier (ASID) field in the TLB
- Think of ASID as a process identifier (PID)
	- 8-bit field

### Page Sharing

- Leveraging ASID for supporting page sharing
- In the example below, two entries from two processes with two different VPNs point to the same physical page:

![[Pasted image 20240625182713.png]]

## TLB Replacement Policies

- When we want to add a new entry to a full TLB, an old entry must be evicted and replaced
- Least-recently-used (LRU) policy
	- intuition: a page entry that hasn't recently been used implies it won't likely be used in the near future
- Random policy
	- evicts an entry at random

### TLB Workloads

- Sequential array accesses can almost always hit in the TLB, and hence are very fast
- What pattern would be slow?
	- Highly random, with no repeat accesses

### Access Patterns

![[Pasted image 20240625183034.png]]

|Aspect|Spatial Locality|Temporal Locality|
|---|---|---|
|Definition|Accessing data elements that are close in memory|Repeatedly accessing the same memory locations|
|Also Known As|Locality in space|Locality in time|
|Typical Scenarios|Array access, structure field access|Loop iterations, repeated function calls|
|Cache Performance|Reduces cache misses by fetching contiguous data|Reduces cache misses by reusing recently accessed data|
|Example|Accessing elements of an array sequentially|Accessing the same variable multiple times in a loop|

Temporal Locality → LRU policy
Sometimes random can be better, policies are heavily dependent by specific TLB workloads


---
# *References*
https://canvas.asu.edu/courses/187584/assignments/5154815?module_item_id=13536097